---
title: 有关
description: '适用于 * * * * 的 Windows 命令主题 '
ms.custom: na
ms.prod: windows-server
ms.reviewer: na
ms.suite: na
ms.technology: manage-windows-commands
ms.tgt_pltfrm: na
ms.topic: article
ms.assetid: e275726c-035f-4a74-8062-013c37f5ded1
author: coreyp-at-msft
ms.author: coreyp
manager: dongill
ms.date: 10/16/2017
ms.openlocfilehash: db0bf54e35e4226cb020b040d5fc36ddd88dc02b
ms.sourcegitcommit: 6aff3d88ff22ea141a6ea6572a5ad8dd6321f199
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 09/27/2019
ms.locfileid: "71377121"
---
# <a name="for"></a>有关



为一组文件中的每个文件运行指定的命令。

有关如何使用此命令的示例，请参阅[示例](#BKMK_examples)。

## <a name="syntax"></a>语法

```
for {%%|%}<Variable> in (<Set>) do <Command> [<CommandLineOptions>]
```

## <a name="parameters"></a>Parameters

|参数|描述|
|---------|-----------|
|{%% \|%} \<Variable >|必需。 表示可替换参数。 使用单个百分号（ **%** ）在命令提示符下执行**for**命令。 使用双百分号（ **%%** ）在批处理文件中执行**for**命令。 变量区分大小写，并且必须使用字母值（如 **% A**、 **% B**或 **% C**）来表示。|
|（\<Set >）|必需。 指定要对其运行命令的一个或多个文件、目录或文本字符串或值的范围。 需要括号。|
|\<Command >|必需。 指定要在每个文件、目录或文本字符串上执行的命令，或在*Set*中包含的值的范围内执行的命令。|
|\<CommandLineOptions >|指定要与指定命令一起使用的任何命令行选项。|
|/?|在命令提示符下显示帮助。|

## <a name="remarks"></a>备注

- 使用**for**

  可以在批处理文件中或直接从命令提示符使用**for**命令。
- 使用批处理参数

  以下属性适用于**for**命令：  
  - **For**命令用指定集中的每个文本字符串替换 **@no__t 2**<em>变量</em>或 **@no__t 5**<em>变量</em>，直到指定的命令处理所有文件。
  - 变量名称区分大小写，全局，并且每次只能激活52。
  - 若要避免与批处理参数 **% 0**到 **% 9**混淆，可以使用除数字0到9之外的任何*变量*字符。 对于简单的批处理文件，一个字符（例如 **%% f** ）将起作用。
  - 可以在复杂的批处理文件中使用*变量*的多个值，以区分不同的可替换变量。
- 指定一组文件

  *Set*参数可以表示一组文件或多组文件。 您可以使用通配符（ **&#42;** 和 **？** ）来指定文件集。 下面是有效的文件集：  
  ```
  (*.doc) 
  (*.doc *.txt *.me)
  (jan*.doc jan*.rpt feb*.doc feb*.rpt)
  (ar??1991.* ap??1991.*)
  ```  
  使用**for**命令时，Set 中的第一个值*将*替换 **%** <em>变量</em>或 **%%** <em>变量</em>，然后指定的命令将处理此值。 这将继续，直到处理完所有与*集*值相对应的文件（或文件组）。
- 使用**in**和**do**关键字

  **在和中** **，不是**参数，但必须将**它们与一起使用。** 如果省略其中任一关键字，则会显示错误消息。
- 使用**的**其他形式

  如果启用了命令扩展（这是默认设置），则支持**以下的附加**形式：  
  - 仅目录

    如果*设置*包含通配符 **&#42;** （或 **？** ），则会对每个目录（而不是指定目录中的一组文件）执行指定的*命令*，以匹配*集*。

    语法为：  
    ```
    for /d {%%|%}<Variable> in (<Set>) do <Command> [<CommandLineOptions>] 
    ```  
  - Recursive

    遍历位于*Drive*：*Path*的根目录树，并在树的每个目录中执行**for**语句。 如果在 **/r**之后未指定目录，将使用当前目录作为根目录。 如果*Set*只是一个句点（.），则它仅枚举目录树。

    语法为：  
    ```
    for /r [[<Drive>:]<Path>] {%%|%}<Variable> in (<Set>) do <Command> [<CommandLineOptions>]
    ```  
  - 迭代值的范围

    使用迭代变量设置起始值（*Start*#），然后单步执行一组值，直到值超过设置的结束值（*End*#）。 **/l**将*开始*# 与*结束*# 进行比较，以执行迭代。 如果*Start*# 小于命令将执行的*结束*#。 当迭代变量超过*End*# 时，命令外壳将退出该循环。 还可以使用负*步骤*# 单步执行递减值中的范围。 例如，（1，1，5）生成序列 1 2 3 4 5，（5，-1，1）生成序列 5 4 3 2 1。

    语法为：  
    ```
    for /l {%%|%}<Variable> in (<Start#>,<Step#>,<End#>) do <Command> [<CommandLineOptions>]
    ```  
  - 迭代和文件分析

    使用文件分析处理命令输出、字符串和文件内容。  使用迭代变量定义要检查的内容或字符串，并使用各种*ParsingKeywords*选项进一步修改分析。  使用*ParsingKeywords*标记选项可指定哪些标记应作为迭代变量传递。 请注意，当不使用令牌选项时， **/f**将仅检查第一个令牌。

    文件分析包括读取输出、字符串或文件内容，然后将其分解为单独的文本行，并将每一行分析为零个或多个标记。 然后，将调用**for**循环，并将迭代变量值设置为标记。 默认情况下， **/f**从每个文件的每一行传递第一个空格分隔标记。 将跳过空白行。

    语法为：  
    ```
    for /f ["<ParsingKeywords>"] {%%|%}<Variable> in (<Set>) do <Command> [<CommandLineOptions>]
    for /f ["<ParsingKeywords>"] {%%|%}<Variable> in ("<LiteralString>") do <Command> [<CommandLineOptions>]
    for /f ["<ParsingKeywords>"] {%%|%}<Variable> in ('<Command>') do <Command> [<CommandLineOptions>]
    ```  
    *Set*参数指定一个或多个文件名。 在移动到*集*内的下一个文件之前，将打开、读取和处理每个文件。 若要覆盖默认的分析行为，请指定*ParsingKeywords*。 这是一个带引号的字符串，其中包含一个或多个用于指定不同分析选项的关键字。

    如果使用**usebackq**选项，请使用以下语法之一：  
    ```
    for /f ["usebackq <ParsingKeywords>"] {%%|%}<Variable> in ("<Set>") do <Command> [<CommandLineOptions>]
    for /f ["usebackq <ParsingKeywords>"] {%%|%}<Variable> in ('<LiteralString>') do <Command> [<CommandLineOptions>]
    for /f ["usebackq <ParsingKeywords>"] {%%|%}<Variable> in (`<Command>`) do <Command> [<CommandLineOptions>]
    ```  
    下表列出了可用于*ParsingKeywords*的分析关键字。  

    |      关键字      |                                                                                                                                                                                                          描述                                                                                                                                                                                                          |
    |-------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
    |     eol = \<c >      |                                                                                                                                                                                   指定行尾字符（仅一个字符）。                                                                                                                                                                                    |
    |     skip = \<N >     |                                                                                                                                                                              指定文件开头要跳过的行数。                                                                                                                                                                              |
    |   delims = \<xxx >   |                                                                                                                                                                     指定分隔符集。 这将替换空格和制表符的默认分隔符集。                                                                                                                                                                      |
    | 标记 = \<X，Y，M – N > | 指定每行的哪些标记要传递到每个迭代的**for**循环。 因此，将分配更多的变量名称。 *M*–*N*指定从*M*到第*N*个标记的范围。 如果**标记 =** 字符串中的最后一个字符是一个星号（ **&#42;** ），则分配一个额外的变量，并在分析的最后一个标记之后的行上接收剩余文本。 |
    |     usebackq      |                                                                                             指定为：执行带引号的字符串作为命令，使用带引号的字符串作为文本字符串; 或者，对于包含空格的长文件名，允许 *\<Set @ no__t-2*中的文件名，每个都用双引号引起来。                                                                                              |


  - 变量替换

    下表列出了可选语法（适用于任何变量**I**）。  

    |带有修饰符的变量|描述|
    |----------------------|-----------|
    |% ~ I|展开 **% I** ，删除所有两侧的引号（""）。|
    |% ~ fI|将 **% I**扩展到完全限定的路径名称。|
    |% ~ dI|仅将 **% I**扩展到驱动器号。|
    |% ~ pI|仅将 **% I**展开为路径。|
    |% ~ nI|仅将 **% I**扩展到文件名。|
    |% ~ xI|仅将 **% I**扩展到文件扩展名。|
    |% ~ sI|将路径展开为仅包含短名称。|
    |% ~ aI|将 **% I**扩展到文件的文件属性。|
    |% ~ tI|将 **% I**扩展到文件的日期和时间。|
    |% ~ zI|将 **% I**扩展到文件的大小。|
    |% ~ $PATH： I|搜索 PATH 环境变量中列出的目录，并将 **% I**扩展到找到的第一个目录的完全限定名称。 如果未定义环境变量名称或搜索找不到该文件，此修饰符将扩展为空字符串。|

    下表列出了可用于获取复合结果的修饰符组合。  

    |包含组合修饰符的变量|描述|
    |--------------------------------|-----------|
    |% ~ dpI|仅将 **% I**扩展到驱动器号和路径。|
    |% ~ nxI|仅将 **% I**扩展到文件名和扩展名。|
    |% ~ Fsi.exe|将 **% I**扩展到仅具有短名称的完整路径名称。|
    |% ~ dp $ PATH： I|在 PATH 环境变量中为 **% I**搜索列出的目录，并将其扩展到找到的第一个驱动器的驱动器号和路径。|
    |% ~ ftzaI|将 **% I**扩展到类似于**dir**的输出行。|

    在上述示例中，可以将 **% I**和 PATH 替换为其他有效值。 有效**的**"变量名称" 终止了 **%~** 语法。

    通过使用大写变量名称（如 **% I**），可以使代码更具可读性，并避免与不区分大小写的修饰符混淆。
- 分析字符串

  可以通过以下两种 @no__t 方式使用**for/f**分析逻辑：双引号（*不带*"usebackq"）或单引号（*带有*"usebackq"），例如（"MyString"）或（' *2LiteralString* ）。MyString '）。 *\<LiteralString @ no__t-2*作为文件中的单个行输入。 当在双引号中分析 *\<LiteralString @ no__t-2*时，会将命令符号（如 **\\ \& \| \>** \^）视为普通字符。
- 分析输出

  您可以使用**for/f**命令来分析命令的输出，方法是在括号之间放置一个反引号 *\<command @ no__t-3* 。 它被视为传递给子 Cmd.exe 的命令行。 将输出捕获到内存中，并将其作为文件进行分析。

## <a name="BKMK_examples"></a>示例

若要**在批处理**文件中使用，请使用以下语法：
```
for {%%|%}<Variable> in (<Set>) do <Command> [<CommandLineOptions>]
```
若要使用可替换变量 **% f**显示当前目录中所有文件的内容，该文件的扩展名为 .doc 或 .txt，请键入：
```
for %f in (*.doc *.txt) do type %f 
```
在前面的示例中，当前目录中具有 .doc 或 .txt 扩展名的每个文件都将替换 **% f**变量，直到显示每个文件的内容。 若要在批处理文件中使用此命令，请将 **% f**的每个匹配项替换为 **%% f**。 否则，将忽略该变量并显示一条错误消息。

若要分析文件，忽略注释行，请键入：
```
for /f "eol=; tokens=2,3* delims=," %i in (myfile.txt) do @echo %i %j %k
```
此命令分析 Myfile.txt 中的每一行。 它将忽略以分号开头的行，并将每一行的第二个和第三个标记传递到**for**正文（标记之间用逗号或空格分隔）。 **For**语句的主体引用 **% i**获取第二个标记， **% j**获取第三个标记，并为 **% k**以获取所有剩余标记。 如果提供的文件名包含空格，请使用引号将文本括起来（例如，"File Name"）。 若要使用引号，必须使用**usebackq**。 否则，引号被解释为定义要分析的文本字符串。

已在**for**语句中显式声明了 **% i** 。 **% j**和 **% k**使用**标记 =** 隐式声明。 可以使用**标记 =** 来指定最多26个标记，前提是它不会导致尝试声明大于字母 "z" 或 "z" 的变量。

下面的示例枚举当前环境中的环境变量名称。 若要分析命令的输出，请*将集*放在括号之间，键入：
```
for /f "usebackq delims==" %i in ('set') do @echo %i 
```

#### <a name="additional-references"></a>其他参考

[命令行语法项](command-line-syntax-key.md)
